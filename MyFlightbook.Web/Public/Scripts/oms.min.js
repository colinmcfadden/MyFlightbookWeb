/*
 OverlappingMarkerSpiderfier
  https://github.com/jawj/OverlappingMarkerSpiderfier
  Copyright (c) 2011 - 2017 George MacKerron
  Released under the MIT licence: http://opensource.org/licenses/mit-license
*/
'use strict'; (function () {
    var D, E, B, H = {}.hasOwnProperty; this.OverlappingMarkerSpiderfier = function () {
        var l, x, p; var u = class {
            constructor(a, c = {}) {
                var b; this.map = a; if (null == this.constructor.hasInitialized) {
                    this.constructor.hasInitialized = !0; r = google.maps; l = r.event; p = r.MapTypeId; g.keepSpiderfied = !1; g.ignoreMapClick = !1; g.markersWontHide = !1; g.markersWontMove = !1; g.basicFormatEvents = !1; g.nearbyDistance = 20; g.circleSpiralSwitchover = 9; g.circleFootSeparation = 23; g.circleStartAngle = A / 12; g.spiralFootSeparation = 26;
                    g.spiralLengthStart = 11; g.spiralLengthFactor = 4; g.spiderfiedZIndex = r.Marker.MAX_ZINDEX + 2E4; g.highlightedLegZIndex = r.Marker.MAX_ZINDEX + 1E4; g.usualLegZIndex = r.Marker.MAX_ZINDEX + 1; g.legWeight = 1.5; g.legColors = { usual: {}, highlighted: {} }; var d = g.legColors.usual; a = g.legColors.highlighted; d[p.HYBRID] = d[p.SATELLITE] = "#fff"; a[p.HYBRID] = a[p.SATELLITE] = "#f00"; d[p.TERRAIN] = d[p.ROADMAP] = "#444"; a[p.TERRAIN] = a[p.ROADMAP] = "#f00"; this.constructor.ProjHelper = function (f) { return this.setMap(f) }; this.constructor.ProjHelper.prototype =
                        new r.OverlayView; this.constructor.ProjHelper.prototype.draw = function () { }
                } for (b in c) H.call(c, b) && (a = c[b], this[b] = a); this.projHelper = new this.constructor.ProjHelper(this.map); this.initMarkerArrays(); this.listeners = {}; this.formatIdleListener = this.formatTimeoutId = null; this.addListener("click", function (f, e) { return l.trigger(f, "spider_click", e) }); this.addListener("format", function (f, e) { return l.trigger(f, "spider_format", e) }); this.ignoreMapClick || l.addListener(this.map, "click", () => this.unspiderfy()); l.addListener(this.map,
                    "maptypeid_changed", () => this.unspiderfy()); l.addListener(this.map, "zoom_changed", () => { this.unspiderfy(); if (!this.basicFormatEvents) return this.formatMarkers() })
            }
        }; var g = u.prototype; var F = [u, g]; var C = 0; for (x = F.length; C < x; C++) { var I = F[C]; I.VERSION = "1.0.3" } var A = 2 * Math.PI; var r = l = p = null; u.markerStatus = { SPIDERFIED: "SPIDERFIED", SPIDERFIABLE: "SPIDERFIABLE", UNSPIDERFIABLE: "UNSPIDERFIABLE", UNSPIDERFIED: "UNSPIDERFIED" }; g.initMarkerArrays = function () { this.markers = []; return this.markerListenerRefs = [] }; g.isVisibleMarker =
            function (a) { return null !== a.map && a.map.getBounds().contains(a.position) }; g.addMarker = function (a, c) { a.setMap(this.map); return this.trackMarker(a, c) }; g.trackMarker = function (a, c) {
                if (null != a._oms) return this; a._oms = !0; var b = [l.addListener(a, "click", d => this.spiderListener(a, d))]; this.markersWontHide || b.push(l.addListener(a, "visible_changed", () => this.markerChangeListener(a, !1))); this.markersWontMove || b.push(l.addListener(a, "position_changed", () => this.markerChangeListener(a, !0))); null != c && b.push(l.addListener(a,
                    "spider_click", c)); this.markerListenerRefs.push(b); this.markers.push(a); this.basicFormatEvents ? this.trigger("format", a, this.constructor.markerStatus.UNSPIDERFIED) : (this.trigger("format", a, this.constructor.markerStatus.UNSPIDERFIABLE), this.formatMarkers()); return this
            }; g.markerChangeListener = function (a, c) { if (!this.spiderfying && !this.unspiderfying) return null == a._omsData || !c && this.isVisibleMarker(a) || this.unspiderfy(c ? a : null), this.formatMarkers() }; g.getMarkers = function () { return this.markers.slice(0) };
        g.removeMarker = function (a) { this.forgetMarker(a); return a.setMap(null) }; g.forgetMarker = function (a) { var c; null != a._omsData && this.unspiderfy(); var b = this.arrIndexOf(this.markers, a); if (0 > b) return this; var d = this.markerListenerRefs.splice(b, 1)[0]; var f = 0; for (c = d.length; f < c; f++) { var e = d[f]; l.removeListener(e) } delete a._oms; this.markers.splice(b, 1); this.formatMarkers(); return this }; g.removeAllMarkers = g.clearMarkers = function () {
            var a; var c = this.getMarkers(); this.forgetAllMarkers(); var b = 0; for (a = c.length; b <
                a; b++) { var d = c[b]; d.setMap(null) } return this
        }; g.forgetAllMarkers = function () { var a, c; this.unspiderfy(); var b = this.markers; var d = a = 0; for (c = b.length; a < c; d = ++a) { var f = b[d]; var e = this.markerListenerRefs[d]; var h = 0; for (d = e.length; h < d; h++) { var k = e[h]; l.removeListener(k) } delete f._oms } this.initMarkerArrays(); return this }; g.addListener = function (a, c) { var b; (null != (b = this.listeners)[a] ? b[a] : b[a] = []).push(c); return this }; g.removeListener = function (a, c) {
            c = this.arrIndexOf(this.listeners[a], c); 0 > c || this.listeners[a].splice(c,
                1); return this
        }; g.clearListeners = function (a) { this.listeners[a] = []; return this }; g.trigger = function (a, ...c) { var b, d; a = null != (b = this.listeners[a]) ? b : []; var f = []; var e = 0; for (d = a.length; e < d; e++)b = a[e], f.push(b(...c)); return f }; g.generatePtsCircle = function (a, c) { var b, d; var f = this.circleFootSeparation * (2 + a) / A; var e = A / a; var h = []; for (b = d = 0; 0 <= a ? d < a : d > a; b = 0 <= a ? ++d : --d)b = this.circleStartAngle + b * e, h.push(new r.Point(c.x + f * Math.cos(b), c.y + f * Math.sin(b))); return h }; g.generatePtsSpiral = function (a, c) {
            var b, d; var f =
                this.spiralLengthStart; var e = 0; var h = []; for (b = d = 0; 0 <= a ? d < a : d > a; b = 0 <= a ? ++d : --d)e += this.spiralFootSeparation / f + 5E-4 * b, b = new r.Point(c.x + f * Math.cos(e), c.y + f * Math.sin(e)), f += A * this.spiralLengthFactor / e, h.push(b); return h
        }; g.spiderListener = function (a, c) {
            var b, d; (d = null != a._omsData) && this.keepSpiderfied || this.unspiderfy(); if (d || this.map.getStreetView().getVisible() || "GoogleEarthAPI" === this.map.getMapTypeId()) return this.trigger("click", a, c); d = []; var f = []; var e = this.nearbyDistance; var h = e * e; var k = this.llToPt(a.position);
            var q = this.markers; e = 0; for (b = q.length; e < b; e++) { var n = q[e]; if (null != n.map && this.isVisibleMarker(n)) { var m = this.llToPt(n.position); this.ptDistanceSq(m, k) < h ? d.push({ marker: n, markerPt: m }) : f.push(n) } } return 1 === d.length ? this.trigger("click", a, c) : this.spiderfy(d, f)
        }; g.markersNearMarker = function (a, c = !1) {
            var b, d, f; if (null == this.projHelper.getProjection()) throw "Must wait for 'idle' event on map before calling markersNearMarker"; var e = this.nearbyDistance; var h = e * e; var k = this.llToPt(a.position); var q = []; var n =
                this.markers; e = 0; for (b = n.length; e < b; e++) { var m = n[e]; if (m !== a && null != m.map && this.isVisibleMarker(m)) { var t = this.llToPt(null != (d = null != (f = m._omsData) ? f.usualPosition : void 0) ? d : m.position); if (this.ptDistanceSq(t, k) < h && (q.push(m), c)) break } } return q
        }; g.markerProximityData = function () {
            var a, c, b, d; if (null == this.projHelper.getProjection()) throw "Must wait for 'idle' event on map before calling markersNearAnyOtherMarker"; var f = this.nearbyDistance; f *= f; var e = this.markers; var h = []; var k = 0; for (c = e.length; k < c; k++) {
                var q =
                    e[k]; h.push({ pt: this.llToPt(null != (a = null != (b = q._omsData) ? b.usualPosition : void 0) ? a : q.position), willSpiderfy: !1 })
            } k = this.markers; a = b = 0; for (q = k.length; b < q; a = ++b)if (c = k[a], null != c.getMap() && this.isVisibleMarker(c)) { var n = h[a]; if (!n.willSpiderfy) { var m = this.markers; c = d = 0; for (e = m.length; d < e; c = ++d) { var t = m[c]; if (c !== a && null != t.getMap() && this.isVisibleMarker(t) && (t = h[c], (!(c < a) || t.willSpiderfy) && this.ptDistanceSq(n.pt, t.pt) < f)) { n.willSpiderfy = t.willSpiderfy = !0; break } } } } return h
        }; g.markersNearAnyOtherMarker =
            function () { var a, c; var b = this.markerProximityData(); var d = this.markers; var f = []; var e = a = 0; for (c = d.length; a < c; e = ++a) { var h = d[e]; b[e].willSpiderfy && f.push(h) } return f }; g.setImmediate = function (a) { return window.setTimeout(a, 0) }; g.formatMarkers = function () {
                if (!this.basicFormatEvents && null == this.formatTimeoutId) return this.formatTimeoutId = this.setImmediate(() => {
                    this.formatTimeoutId = null; return null != this.projHelper.getProjection() ? this._formatMarkers() : null != this.formatIdleListener ? void 0 : this.formatIdleListener =
                        l.addListenerOnce(this.map, "idle", () => this._formatMarkers())
                })
            }; g._formatMarkers = function () {
                var a; if (this.basicFormatEvents) { var c = []; var b = 0; for (a = markers.length; b < a; b++) { var d = markers[b]; var f = null != d._omsData ? "SPIDERFIED" : "UNSPIDERFIED"; c.push(this.trigger("format", d, this.constructor.markerStatus[f])) } return c } c = this.markerProximityData(); var e = this.markers; var h = []; f = a = 0; for (b = e.length; a < b; f = ++a)d = e[f], f = null != d._omsData ? "SPIDERFIED" : c[f].willSpiderfy ? "SPIDERFIABLE" : "UNSPIDERFIABLE", h.push(this.trigger("format",
                    d, this.constructor.markerStatus[f])); return h
            }; g.makeHighlightListenerFuncs = function (a) { return { highlight: () => a._omsData.leg.setOptions({ strokeColor: this.legColors.highlighted[this.map.mapTypeId], zIndex: this.highlightedLegZIndex }), unhighlight: () => a._omsData.leg.setOptions({ strokeColor: this.legColors.usual[this.map.mapTypeId], zIndex: this.usualLegZIndex }) } }; g.spiderfy = function (a, c) {
                var b, d, f, e, h, k, q; this.spiderfying = !0; var n = a.length; var m = this.ptAverage(function () {
                    var y; var z = []; var v = 0; for (y = a.length; v <
                        y; v++)k = a[v], z.push(k.markerPt); return z
                }()); var t = n >= this.circleSpiralSwitchover ? this.generatePtsSpiral(n, m).reverse() : this.generatePtsCircle(n, m); m = function () {
                    var y; var z = []; var v = 0; for (y = t.length; v < y; v++)d = t[v], b = this.ptToLl(d), q = this.minExtract(a, J => this.ptDistanceSq(J.markerPt, d)), h = q.marker, e = new r.Polyline({ map: this.map, path: [h.position, b], strokeColor: this.legColors.usual[this.map.mapTypeId], strokeWeight: this.legWeight, zIndex: this.usualLegZIndex }), h._omsData = {
                        usualPosition: h.position, usualZIndex: h.zIndex,
                        leg: e
                    }, this.legColors.highlighted[this.map.mapTypeId] !== this.legColors.usual[this.map.mapTypeId] && (f = this.makeHighlightListenerFuncs(h), h._omsData.hightlightListeners = { highlight: l.addListener(h, "mouseover", f.highlight), unhighlight: l.addListener(h, "mouseout", f.unhighlight) }), this.trigger("format", h, this.constructor.markerStatus.SPIDERFIED), h.position = b, h.zIndex = Math.round(this.spiderfiedZIndex + d.y), z.push(h); return z
                }.call(this); delete this.spiderfying; this.spiderfied = !0; return this.trigger("spiderfy",
                    m, c)
            }; g.unspiderfy = function (a = null) {
                var c; if (null == this.spiderfied) return this; this.unspiderfying = !0; var b = []; var d = []; var f = this.markers; var e = 0; for (c = f.length; e < c; e++) {
                    var h = f[e]; if (null != h._omsData) {
                        h._omsData.leg.setMap(null); h !== a && (h.position = h._omsData.usualPosition); h.zIndex = h._omsData.usualZIndex; var k = h._omsData.hightlightListeners; null != k && (l.removeListener(k.highlight), l.removeListener(k.unhighlight)); delete h._omsData; h !== a && (k = this.basicFormatEvents ? "UNSPIDERFIED" : "SPIDERFIABLE", this.trigger("format",
                            h, this.constructor.markerStatus[k])); b.push(h)
                    } else d.push(h)
                } delete this.unspiderfying; delete this.spiderfied; this.trigger("unspiderfy", b, d); return this
            }; g.ptDistanceSq = function (a, c) { var b = a.x - c.x; a = a.y - c.y; return b * b + a * a }; g.ptAverage = function (a) { var c, b, d; var f = b = d = 0; for (c = a.length; f < c; f++) { var e = a[f]; b += e.x; d += e.y } a = a.length; return new r.Point(b / a, d / a) }; g.llToPt = function (a) { return this.projHelper.getProjection().fromLatLngToDivPixel(a) }; g.ptToLl = function (a) { return this.projHelper.getProjection().fromDivPixelToLatLng(a) };
        g.minExtract = function (a, c) { var b, d; var f = b = 0; for (d = a.length; b < d; f = ++b) { var e = a[f]; e = c(e); if ("undefined" === typeof k || null === k || e < h) { var h = e; var k = f } } return a.splice(k, 1)[0] }; g.arrIndexOf = function (a, c) { return null != a.indexOf ? a.indexOf(c) : -1 }; return u
    }.call(this); var G = /(\?.*(&|&amp;)|\?)spiderfier_callback=(\w+)/; var w = document.currentScript; null == w && (w = function () {
        var l, x; var p = document.getElementsByTagName("script"); var u = []; var g = 0; for (l = p.length; g < l; g++)B = p[g], null != (x = B.getAttribute("src")) && x.match(G) &&
            u.push(B); return u
    }()[0]); if (null != w && (w = null != (D = w.getAttribute("src")) ? null != (E = D.match(G)) ? E[3] : void 0 : void 0) && "function" === typeof window[w]) window[w](); "function" === typeof window.spiderfier_callback && window.spiderfier_callback()
}).call(this);